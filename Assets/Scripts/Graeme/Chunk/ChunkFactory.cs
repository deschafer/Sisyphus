using UnityEngine;

/*
	ChunkFactory
	Used to create chunks. The cellular automata logic is contained here.
*/
public class ChunkFactory {

	/*
		GenerateChunk()
		Parameters: Initial chance for a cell to be occupied, number of times to smooth, number of neighbors required for a birth or death.
		Returns: Newly created chunk containing the cells set as generated by cellular automata.
		Purpose: Create, initialize, and return the chunk so it can be rendered and populated later on.
	*/
	public static Chunk GenerateChunk(int spawnChance, int iterations, int birthCount, int deathCount) {
		int[,] cells = new int[Chunk.CHUNK_WIDTH,Chunk.CHUNK_HEIGHT];

		InitializeCells(cells, spawnChance);
		SmoothCells(cells, iterations, birthCount, deathCount);

		return new Chunk(cells);
	}

	/*
		InitializeCells
		Purpose: Sets all cells in map to an initial value of either 0 or 1 based on RNG, initialChance, and the height of the cell.
		Parameters: The 2D array of cells to initialize.
	*/
	public static void InitializeCells(int[,] grid, int spawnChance) {
		for (int x = 0; x < Chunk.CHUNK_WIDTH; x++)
			for (int y = 0; y < Chunk.CHUNK_HEIGHT; y++)
				grid[x, y] = Random.Range(0, 100) < (spawnChance * y / Chunk.CHUNK_HEIGHT) ? 1 : 0;
	}

	/*
		SmoothCells
		Purpose: Uses cellular automata to make the cells more closely resemble an actual landscape when they are used to create a chunk.
		Parameters: The initialized 2D array of cells to smooth, number of iterations to run the smoothing algorithm, number of neighbors required for a death or birth.
	*/
	public static void SmoothCells(int[,] grid, int iterations, int birthCount, int deathCount) {
		for(int i = 0; i < iterations; i++) {
			for(int x = 0; x < Chunk.CHUNK_WIDTH; x++) {
				for(int y = 0; y < Chunk.CHUNK_HEIGHT; y++) {
					int neighbors = GetNeighborCount(grid, x, y);
					if(neighbors >= birthCount)
						grid[x,y] = 1;
					else if(neighbors <= deathCount)
						grid[x,y] = 0;
				}
			}
		}
	}
	
	/*
		GetNeighborCount
		Purpose: Find the number of neighbors given cell has.
		Parameters: Grid to check in, x and y coordinates of position to check.
		Returns: Number of occupied cells adjacent to the given cell.
	*/
	private static int GetNeighborCount(int[,] grid, int x, int y) {
		int count = 0;
		for(int i = -1; i < 2; i++)
			for(int j = -1; j < 2; j++)
				if(x + i >= 0 && x + i < Chunk.CHUNK_WIDTH && y + j >= 0 && y + j < Chunk.CHUNK_HEIGHT)
					count += grid[x + i, y + j];
		return count;
	}

}
